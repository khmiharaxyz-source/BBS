// スレッドの有効期限（12時間 = 12 * 60 * 60 * 1000 ミリ秒）
const EXPIRE_TIME = 12 * 60 * 60 * 1000;

// 古いスレッドを掃除する関数
function autoCleanup(boardName) {
    const now = new Date().getTime();
    const boardRef = db.ref('boards/' + boardName);

    // 一度だけデータを読み取ってチェック
    boardRef.once('value', (snapshot) => {
        const data = snapshot.val();
        if (!data) return;

        Object.keys(data).forEach(key => {
            const lastUpdateStr = data[key].lastUpdate;
            const lastUpdateDate = new Date(lastUpdateStr).getTime();

            // 最終更新から12時間以上経っていたら削除
            if (now - lastUpdateDate > EXPIRE_TIME) {
                console.log(`削除対象スレッド: ${data[key].title} (ID: ${key})`);
                db.ref('boards/' + boardName + '/' + key).remove()
                  .then(() => console.log("削除成功"))
                  .catch(err => console.error("削除失敗", err));
            }
        });
    });
}

// 板を開くときの処理に「掃除」を組み込む
function openBoard(name) {
    currentBoard = name;
    
    // UIの切り替え
    document.getElementById('portal-view').classList.add('hidden');
    document.getElementById('index-view').classList.remove('hidden');
    document.getElementById('global-footer').classList.add('hidden');
    
    // 【追加】板を開いた瞬間に古いスレッドを掃除する
    autoCleanup(name);

    // スレッド一覧の取得（リアルタイム監視）
    const boardRef = db.ref('boards/' + currentBoard);
    boardRef.on('value', (snapshot) => {
        const data = snapshot.val() || {};
        // データを配列に変換して新しい順に並べる
        const threads = Object.keys(data).map(key => ({...data[key], key})).reverse();
        renderIndexUI(threads); 
    });
}